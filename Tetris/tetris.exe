#include "tetris.h"

// on start
Menu::Menu() {
	start:;
	system("cls");
	system("color 0F");
	ifstream Mylogo;
	Mylogo.open("TetrisHeadline.txt");
	string logo[logo_size];
	int printed_size = 0;
	while (!Mylogo.eof()) {
		getline(Mylogo, logo[printed_size++]);
	}
	rep(i, 0, printed_size) {
		gotoxy(25, 10 + i);
		rep(j, 0, logo[i].size()) {
			if (logo[i][j] != ' ') {
				if (logo[i][j] == 'T') SetColor(13);
				else if (logo[i][j] == 'E') SetColor(12);
				else if (logo[i][j] == 'R') SetColor(10);
				else if (logo[i][j] == 'I') SetColor(9);
				else SetColor(15);
				cout << char(219);
			}
			else
				cout << ' ';
		}
		cout << endl;
	}
	Game event;
	StartMenu(event);
	while (true) {
		if (GetAsyncKeyState(VK_DOWN)) {
			if (event.UserChoice + 1 >= 4)
				continue;
			event.UserChoice += 1;
			StartMenu(event);
			Sleep(100);
		}
		if (GetAsyncKeyState(VK_UP)) {
			if (event.UserChoice - 1 < 0)
				continue;
			event.UserChoice -= 1;
			StartMenu(event);
			Sleep(100);
		}
		if (GetAsyncKeyState(VK_RETURN)) {
			system("cls");
			if (event.UserChoice == 0) {
				runTetris();
				return;
			}
			else if (event.UserChoice == 1) {
				ifstream MyFile;
				MyFile.open("controlls.txt");
				while (!MyFile.eof()) {
					string instructions;
					getline(MyFile, instructions);
					cout << instructions << endl;
				}
				while (true) {
					if (GetAsyncKeyState(VK_BACK)) {
						system("cls");
						goto start;
					}
				}
			}
			else if (event.UserChoice == 2) {
				ifstream MyFile;
				MyFile.open("credits.txt");
				while (!MyFile.eof()) {
					string credits;
					getline(MyFile, credits);
					cout << credits << endl;
				}
				while (true) {
					if (GetAsyncKeyState(VK_BACK)) {
						system("cls");
						goto start;
					}
				}
			}
			else if (event.UserChoice == 3) {
				system("Color 0F");
				SetCursorToPosition(20, 10, 14);
				cout << "Thank You For Playing My Tetris Game";
				SetCursorToPosition(20, 13, 14);
				cout << "I Love You :)";
				SetCursorToPosition(20, 20, 14);
				return;
			}
			return;
		}
	}
}
void Menu::StartMenu(Game game) {
	int ShifTs = 0;
	string temp_Menu[] = {"Play Mode", "Controls", "Credits", "Quit"};
	rep(i, 0, game.row) {
		game.Menu[i] = temp_Menu[i];
		SetCursorToPosition(50, i + 20 + ShifTs, 14);
		if (game.UserChoice == i)
			SetCursorToPosition(50, i + 20 + ShifTs, 23);
		cout << game.Menu[i];
		ShifTs += 2;
	}
}


//  blocks movement
void move_down(Game& game, collisionTest test, bool& get_out) {
	if (test.Downcollision(game)) {
		get_out = true;
		return;
	}
	Recover_Grid(game);

	shift_Down(game);

	if (!isvalid(game)) {

		set_pawn(game);

		ClearScreen(game);

		get_out = true;
		return;
	}

	set_pawn(game);

	ClearScreen(game);
}
void move_right(Game& game, collisionTest test) {
	Recover_Grid(game);

	shift_Right(game);

	set_pawn(game);

	//system("cls");

	ClearScreen(game);
}
void move_left(Game& game, collisionTest test) {
	Recover_Grid(game);

	shift_Left(game);

	set_pawn(game);

	//system("cls");

	ClearScreen(game);
}
void Recover_Grid(Game& game) {
	rep(i, 0, game.row) {
		rep(j, 0, game.col - 1) {
			int I = game.position[i][j];
			int J = game.position[i][j + 1];
			game.grid[I][J] = ' ';
		}
	}
}
void shift_Left(Game& game) {
	rep(i, 0, game.row)
		game.position[i][1]--;
}
void shift_Right(Game& game) {
	rep(i, 0, game.row)
		game.position[i][1]++;
}
void shift_Down(Game& game) {
	rep(i, 0, game.row)
		game.position[i][0]++;
}
void set_pawn(Game& game) {
	rep(i, 0, game.row) {
		rep(j, 0, game.col - 1) {
			int I = game.position[i][j];
			int J = game.position[i][j + 1];
			game.grid[I][J] = char(219);
		}
	}
}
bool isvalid(Game game) {
	rep(i, 0, game.row) {
		int I = game.position[i][0];
		int J = game.position[i][1];
		if (game.grid[I][J] != ' ')
			return false;

	}
	return true;
}


// score managment
void ApplyGravity(Game& game,int CompleteRow) {
	for (int j = 1; j < sizeof_col - 1; j++) {
		game.grid[CompleteRow][j] = ' ';
	}
	for (int i = CompleteRow; i > 1; i--) {
		for (int j = sizeof_col - 1; j > 0; j--) {
			game.grid[i][j] = game.grid[i - 1][j];
		}
	}
}
int iscompleteline(Game game) {
	for (int i = sizeof_row - 2; i >= 1; i--) {
		int c = 0;
		for (int j = 1; j < sizeof_col - 1; j++) {
			if (game.grid[i][j] == char(219))
				c++;
			if (game.grid[i][j] == ' ')
				break;
		}
		if (c == sizeof_col - 2)
			return i;
	}
	return 0;
}
bool isGameOver(Game game) {
	rep(i, 0, sizeof_row) {
		if (game.grid[2][i] == char(219) || game.grid[3][i] == char(219))
			return 1;
	}
	return 0;

}


/// the game
void runTetris() {
	Game event;
	collisionTest test;
	set_grid(event);
	ClearScreen(event);
	bool next = 0;
	srand(time(NULL));
	int next_choice = rand() % 7;
	int choice = rand() % 7;
	while (true) {
		int X = 3, Y = sizeof_row / 2 - 1;
		int CompleteLine = iscompleteline(event);
		while (CompleteLine) {
			ApplyGravity(event, CompleteLine);
			event.total_score += 1000;
			CompleteLine = iscompleteline(event);
		}
		set_ALL_pawns(event, X, Y);
		int current_choose[] = {1, 5, 9, 13, 17, 21, 25}, bound_of_choosen_pawn = 0;
		if (!next) {
			bound_of_choosen_pawn = choice;
			event.select = current_choose[next_choice] + 1;
			ChoosePawn(event);
			next = !next;
			choice = rand() % 7;
		}
		else {
			bound_of_choosen_pawn = next_choice;
			event.select = current_choose[choice] + 1;
			ChoosePawn(event);
			next = !next;
			next_choice = rand() % 7;
		}
		ShowNextPawn(event);
		event.select = current_choose[bound_of_choosen_pawn] + 1;
		ChoosePawn(event);
		if (isGameOver(event)) {
			ClearScreen(event);
			SetColor(12);
			printf_s("\n\n\n\t\tGame Over\n");
			printf_s("\n\n\t\tFinal Score : %d\n\n\n\n\n", event.total_score);
			printf_s("\n\n\t\tback To return to game menu\n");
			printf_s("\n\n\t\tspace bar To quit\n");
			while (true) {
				if (GetAsyncKeyState(VK_BACK)) {
					Menu Start;
					return;
				}
				if (GetAsyncKeyState(VK_SPACE)) {
					system("Color 0F");
					SetCursorToPosition(20, 10, 14);
					cout << "\t\tThank You For Playing My Tetris Game";
					SetCursorToPosition(20, 13, 14);
					cout << "\t\tI Love You :)";
					SetCursorToPosition(20, 20, 14);
					return;
				}
			}
			Sleep(1000);
		}
		if (event.Levels > 3) {
			system("Color 0F");
			system("cls");
			SetCursorToPosition(30 + 5, 20, 14);
			cout << "Congratulations ! You Have Finished The Game , You'r My Hero";
			SetCursorToPosition(30 + 5, 22, 14);
			printf_s("\t\tback To return to game menu");
			SetCursorToPosition(30 + 5, 24, 14);
			printf_s("\t\tspace bar To quit");
			while (true) {
				if (GetAsyncKeyState(VK_BACK)) {
					Menu Start;
					return;
				}
				if (GetAsyncKeyState(VK_SPACE)) {
					system("cls");
					system("Color 0F");
					SetCursorToPosition(20, 10, 14);
					cout << "\t\tThank You For Playing My Tetris Game";
					SetCursorToPosition(20, 13, 14);
					cout << "\t\tI Love You :)";
					SetCursorToPosition(20, 20, 14);
					return;
				}
			}
		}
		if (event.total_score >= event.LevelScore[event.Levels]) {
			system("Color 0F");
			system("cls");
			SetCursorToPosition(30 + 5, 20, 14);
			cout << "Congratulations ! You Have Reached The Next Level very Nice";
			SetCursorToPosition(30 + 10 + 5, 20 + 1, 14);
			cout << "press Enter To continue to next level";
			event.Levels += 1;
			cin.get();
			set_grid(event);
			event.total_score = 0;
			event.Difficulty -= 20;
			if (event.Difficulty <= 0)
				event.Difficulty += 20;
			system("cls");
			continue;
		}
		set_pawn(event);
		while (true) {
			Sleep(event.Difficulty);
			if (!test.Downcollision(event)) {
				bool get_out = 0;
				move_down(event, test, get_out);
				if (get_out)
					break;
				X++;
				set_ALL_pawns(event, X, Y);
			}
			else
				break;

			if (GetAsyncKeyState(VK_DOWN)) {
				bool get_out = 0;
				move_down(event, test, get_out);
				if (get_out)
					break;
				X++;
				set_ALL_pawns(event, X, Y);
			}

			if (GetAsyncKeyState(VK_RIGHT)) {
				if (test.Rightcollision(event))
					continue;
				move_right(event, test);
				Y++;
				set_ALL_pawns(event, X, Y);
			}

			if (GetAsyncKeyState(VK_LEFT)) {
				if (test.Leftcollision(event))
					continue;
				move_left(event, test);
				Y--;
				set_ALL_pawns(event, X, Y);
			}
			// rotate 
			if (GetAsyncKeyState(VK_UP)) {
				if (X == sizeof_row - 2 || Y == sizeof_col - 2)
					continue;
				int prev_select = event.select;
				Recover_Grid(event);
				event.select += 1;
				//check
				if (event.select > current_choose[bound_of_choosen_pawn] + 3)
					event.select = current_choose[bound_of_choosen_pawn];
				ChoosePawn(event);
				if (test.Rotationcollision(event)) {
					event.select = prev_select;
					ChoosePawn(event);
					if (test.Downcollision(event))
						set_pawn(event);
					else
						continue;
				}
			}
			if (GetAsyncKeyState(VK_ESCAPE)) {
				system("Color 0F");
				ClearScreen(event);
				SetCursorToPosition(15, 40, 11);
				cout << "Game is paused";
				SetCursorToPosition(15, 42, 11);
				cout << "Press Enter To Continue The Game\n";
				cin.get();
				SetCursorToPosition(15, 40, 11);
				cout << "\t\t\t\t\t\t\t\t\t";
				SetCursorToPosition(15, 42, 11);
				cout << "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n";
			}
			if (GetAsyncKeyState(VK_SPACE)) {
				bool get_out = 0;
				while (!test.Downcollision(event))
					move_down(event, test, get_out);
				if (get_out)
					break;
			}
		}
		event.total_score += 30;
	}
}


// about game's map and positions
void SetCursorToPosition(int x, int y, int _color) {
	//PlaySound(TEXT("recycle.wav"), NULL, SND_FILENAME);

	HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
	COORD pos = {x, y};
	SetConsoleCursorPosition(out, pos);
	SetConsoleTextAttribute(out, _color);
}
void gotoxy(int x, int y) {
	HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
	COORD pos = {x, y};
	SetConsoleCursorPosition(out, pos);
}
void SetColor(int color) {
	HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(out, color);
}
void ClearScreen(Game game) {
	if (game.Levels > 3) {
		system("cls");
		SetCursorToPosition(30 + 5, 20, 14);
		cout << "Congratulations ! You Have Finished The Game";
		printf_s("\t\tback To return to game menu\n");
		printf_s("\t\tspace bar To quit\n");
		while (true) {
			if (GetAsyncKeyState(VK_BACK)) {
				Menu Start;
				return;
			}
			if (GetAsyncKeyState(VK_SPACE)) {
				system("cls");
				system("Color 0F");
				SetCursorToPosition(20, 10, 14);
				cout << "Thank You For Playing Da Tetris Game";
				SetCursorToPosition(20, 13, 14);
				cout << "Come Back Later For More";
				SetCursorToPosition(20, 20, 14);
				return;
			}
		}
		return;
	}
	SetCursorToPosition(15 + 23 + 6, 15, 14);
	cout << " Level " << game.Levels;
	SetCursorToPosition(15 + 23 + 6, 15 + 1, 14);
	cout << " Score : " << game.total_score;
	if (game.Levels == 3) {
		for (int i = 15, ipos = 0; ipos < sizeof_col; i++, ipos++) {
			gotoxy(15 + 1, i);
			for (int j = 15, jpos = 0; jpos < sizeof_row; j++, jpos++) {
				if (game.grid[jpos][ipos] == char(177))
					SetColor(17);
				else if (game.grid[jpos][ipos] == char(219))
					SetColor(10);
				else
					SetColor(0);
				cout << game.grid[jpos][ipos];
			}
			cout << endl;
		}
	}
	else {

		for (int i = 15, ipos = 0; ipos < sizeof_row; i++, ipos++) {
			gotoxy(15 + 1, i);
			for (int jpos = 0; jpos < sizeof_col; jpos++) {
				if (game.grid[ipos][jpos] == char(177))
					SetColor(17);
				else if (game.grid[ipos][jpos] == char(219))
					SetColor(10);
				else
					SetColor(0);
				cout << game.grid[ipos][jpos];
			}
			cout << endl;
		}
	}
}

// blocks positions, rotates, defult map
void set_ALL_pawns(Game& game, int X, int Y) {
	// A
	game.block[1] = {{X, Y},
					 {X, Y + 1},
					 {X, Y + 2},
					 {X, Y + 3}};
	game.block[2] = {{X - 2, Y},
					 {X - 1, Y},
					 {X,     Y},
					 {X + 1, Y}};
	game.block[3] = {{X, Y},
					 {X, Y + 1},
					 {X, Y + 2},
					 {X, Y + 3}};
	game.block[4] = {{X - 2, Y},
					 {X - 1, Y},
					 {X,     Y},
					 {X + 1, Y}};

	// B
	game.block[5] = {{X,     Y},
					 {X,     Y + 1},
					 {X + 1, Y},
					 {X + 1, Y + 1}};
	game.block[6] = {{X,     Y},
					 {X,     Y + 1},
					 {X + 1, Y},
					 {X + 1, Y + 1}};
	game.block[7] = {{X,     Y},
					 {X,     Y + 1},
					 {X + 1, Y},
					 {X + 1, Y + 1}};
	game.block[8] = {{X,     Y},
					 {X,     Y + 1},
					 {X + 1, Y},
					 {X + 1, Y + 1}};

	// C
	game.block[9] = {{X,     Y},
					 {X,     Y + 1},
					 {X - 1, Y + 1},
					 {X - 1, Y + 2}};
	game.block[10] = {{X,     Y},
					  {X + 1, Y},
					  {X + 1, Y + 1},
					  {X + 2, Y + 1}};
	game.block[11] = {{X,     Y},
					  {X,     Y + 1},
					  {X - 1, Y + 1},
					  {X - 1, Y + 2}};
	game.block[12] = {{X,     Y},
					  {X + 1, Y},
					  {X + 1, Y + 1},
					  {X + 2, Y + 1}};

	// D
	game.block[13] = {{X,     Y},
					  {X,     Y + 1},
					  {X + 1, Y + 1},
					  {X + 1, Y + 2}};
	game.block[14] = {{X,     Y},
					  {X + 1, Y},
					  {X + 1, Y - 1},
					  {X + 2, Y - 1}};
	game.block[15] = {{X,     Y},
					  {X,     Y + 1},
					  {X + 1, Y + 1},
					  {X + 1, Y + 2}};
	game.block[16] = {{X,     Y},
					  {X + 1, Y},
					  {X + 1, Y - 1},
					  {X + 2, Y - 1}};

	// E
	game.block[17] = {{X,     Y},
					  {X,     Y - 1},
					  {X + 1, Y - 1},
					  {X + 2, Y - 1}};
	game.block[18] = {{X,     Y},
					  {X,     Y + 1},
					  {X,     Y + 2},
					  {X + 1, Y + 2}};
	game.block[19] = {{X,     Y},
					  {X + 1, Y},
					  {X + 2, Y},
					  {X + 2, Y - 1}};
	game.block[20] = {{X,     Y},
					  {X + 1, Y},
					  {X + 1, Y + 1},
					  {X + 1, Y + 2}};

	// F
	game.block[21] = {{X,     Y},
					  {X,     Y + 1},
					  {X + 1, Y + 1},
					  {X + 2, Y + 1}};
	game.block[22] = {{X,     Y},
					  {X,     Y + 1},
					  {X,     Y + 2},
					  {X - 1, Y + 2}};
	game.block[23] = {{X,     Y},
					  {X + 1, Y},
					  {X + 2, Y},
					  {X + 2, Y + 1}};
	game.block[24] = {{X,     Y},
					  {X + 1, Y},
					  {X,     Y + 1},
					  {X,     Y + 2}};

	// G
	game.block[25] = {{X,     Y},
					  {X,     Y + 1},
					  {X - 1, Y + 1},
					  {X,     Y + 2}};
	game.block[26] = {{X,     Y},
					  {X + 1, Y},
					  {X + 1, Y + 1},
					  {X + 2, Y}};
	game.block[27] = {{X,     Y},
					  {X,     Y + 1},
					  {X + 1, Y + 1},
					  {X,     Y + 2}};
	game.block[28] = {{X,     Y},
					  {X + 1, Y},
					  {X + 1, Y - 1},
					  {X + 2, Y}};

	// score to pass levels [ 3 ]
	game.LevelScore[1] = 4000;
	game.LevelScore[2] = 10000;
	game.LevelScore[3] = 5000;
}
void set_grid(Game& game) {
	memset(game.grid, ' ', sizeof(game.grid));
	rep(i, 0, sizeof_row) {
		game.grid[i][0] = char(177);
		game.grid[sizeof_row - 1][i] = char(177);
		if (i < sizeof_col)
			game.grid[0][i] = char(177);
	}
	rep(i, 0, sizeof_row) {
		game.grid[i][sizeof_col - 1] = char(177);
	}
}
void ChoosePawn(Game& game) {
	for (int i = 0; i < game.row; i++) {
		for (int j = 0; j < game.col; j++) {
			game.position[i][j] = game.block[game.select][i][j];
		}
	}
}
void ShowNextPawn(Game game) {
	bool next_shape[7][7];
	memset(next_shape, 0, sizeof(next_shape));
	rep(i, 0, game.row) {
		int I = game.position[i][0];
		int J = game.position[i][1];
		next_shape[I][J] = true;
	}
	rep(i, 0, 7) {
		SetCursorToPosition(15 + 23 + 7, 5 + 15 + i, 11);
		rep(j, 0, 7) {
			if (next_shape[i][j])
				cout << char(219);
			else
				cout << ' ';
		}
		cout << endl;
	}
	SetCursorToPosition(15 + 23 + 7, 5 + 15, 14);
	cout << "Next Block : ";
}


// collision test
bool collisionTest::Downcollision(Game game) {
	int choice = game.select;
	if (choice == 1 || choice == 3)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ' ||
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 2 || choice == 4)
		return
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 5 || choice == 6 || choice == 7 || choice == 8)
		return
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 9 || choice == 11)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 10 || choice == 12)
		return
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ' ||
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ';
	else if (choice == 13 || choice == 15)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 14 || choice == 16)
		return
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ' ||
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ';
	else if (choice == 17)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 18)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 19)
		return
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ' ||
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ';
	else if (choice == 20)
		return
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ' ||
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 21)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 22)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ';
	else if (choice == 23)
		return
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 24)
		return
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ' ||
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 25)
		return
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ' ||
				game.grid[game.position[1][0] + 1][game.position[1][1]] != ' ';
	else if (choice == 26)
		return
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	else if (choice == 27)
		return
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ' ||
				game.grid[game.position[0][0] + 1][game.position[0][1]] != ' ';
	else if (choice == 28)
		return
				game.grid[game.position[2][0] + 1][game.position[2][1]] != ' ' ||
				game.grid[game.position[3][0] + 1][game.position[3][1]] != ' ';
	return false;
}
bool collisionTest::Rightcollision(Game game) {
	int choice = game.select;
	if (choice == 1 || choice == 3)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ';
	else if (choice == 2 || choice == 4)
		return
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ';
	else if (choice == 5 || choice == 6 || choice == 7 || choice == 8)
		return
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ';
	else if (choice == 9 || choice == 11)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ';
	else if (choice == 10 || choice == 12)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ';
	else if (choice == 13 || choice == 15)
		return
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ';
	else if (choice == 14 || choice == 16)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ';
	else if (choice == 17)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ';
	else if (choice == 18)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ';
	else if (choice == 19)
		return
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ';
	else if (choice == 20)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ';
	else if (choice == 21)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ';
	else if (choice == 22)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ';
	else if (choice == 23)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ';
	else if (choice == 24)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ';
	else if (choice == 25)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ';
	else if (choice == 26)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ';
	else if (choice == 27)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] + 1] != ' ';
	else if (choice == 28)
		return
				game.grid[game.position[3][0]][game.position[3][1] + 1] != ' ' ||
				game.grid[game.position[0][0]][game.position[0][1] + 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] + 1] != ' ';
	return false;
}
bool collisionTest::Leftcollision(Game game) {
	int choice = game.select;
	if (choice == 1 || choice == 3)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ';
	else if (choice == 2 || choice == 4)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 5 || choice == 6 || choice == 7 || choice == 8)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ';
	else if (choice == 9 || choice == 11)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ';
	else if (choice == 10 || choice == 12)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 13 || choice == 15)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ';
	else if (choice == 14 || choice == 16)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 17)
		return
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 18)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 19)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 20)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ';
	else if (choice == 21)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 22)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 23)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ';
	else if (choice == 24)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ';
	else if (choice == 25)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ';
	else if (choice == 26)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[1][0]][game.position[1][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	else if (choice == 27)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ';
	else if (choice == 28)
		return
				game.grid[game.position[0][0]][game.position[0][1] - 1] != ' ' ||
				game.grid[game.position[2][0]][game.position[2][1] - 1] != ' ' ||
				game.grid[game.position[3][0]][game.position[3][1] - 1] != ' ';
	return false;
}
bool collisionTest::Rotationcollision(Game game) {
	return
			Leftcollision(game) ||
			Rightcollision(game) ||
			Downcollision(game);
}